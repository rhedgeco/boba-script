use boba_script_ast::{
    Expr,
    Statement,
};
use boba_script_lexer::{
    Token,
    LexerError,
    token::build::{
        IntBuilder,
        FloatBuilder,
        StrFormat,
    },
};

grammar<'input>(input: &'input str);

Atom: Expr = {
    None => Expr::none(),
    <v:Bool> => Expr::bool(v),
    <v:Int> => Expr::int(v.build()),
    <v:Float> => Expr::float(v.build()),
    <v:Str> => Expr::str(v.format()),
    <v:Ident> => Expr::var(v.to_string()),
    "(" <Expr> ")",
};

pub Expr: Expr = {
    #[precedence(level="0")]
    <Atom>,

    #[precedence(level="1")] #[assoc(side="right")]
    <l:Expr> "**" <r:Expr> => l.pow(r),

    #[precedence(level="2")] #[assoc(side="right")]
    "+" <e: Expr> => e.pos(),
    "-" <e: Expr> => e.neg(),
    "!" <e: Expr> => e.not(),

    #[precedence(level="3")] #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => l.add(r),
    <l:Expr> "-" <r:Expr> => l.sub(r),

    #[precedence(level="4")] #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => l.mul(r),
    <l:Expr> "/" <r:Expr> => l.div(r),
    <l:Expr> "%" <r:Expr> => l._mod(r),

    #[precedence(level="5")] #[assoc(side="left")]
    <l:Expr> "&&" <r:Expr> => l.and(r),
    <l:Expr> "||" <r:Expr> => l.or(r),

    #[precedence(level="6")] #[assoc(side="left")]
    <l:Expr> "==" <r:Expr> => l.eq(r),
    <l:Expr> "<" <r:Expr> => l.lt(r),
    <l:Expr> ">" <r:Expr> => l.gt(r),
    <l:Expr> "!=" <r:Expr> => l.neq(r),
    <l:Expr> "<=" <r:Expr> => l.lteq(r),
    <l:Expr> ">=" <r:Expr> => l.gteq(r),
};

pub Statement: Statement = {
    <InlineStatement>,
    <IfStatement>,
    <WhileStatement>,
};

InlineStatement: Statement = {
    <Expr> "\n" => Statement::expr(<>),
    <l:Expr> "=" <r:Expr> "\n" => Statement::assign(l, r),
};

IfStatement: Statement = {
    "if" <cond:Expr> ":" "\n" => Statement::_if(cond, vec![]),
    "if" <cond:Expr> ":" <s:InlineStatement> => Statement::_if(cond, vec![s]),
    "if" <cond:Expr> ":" "\n" <block:StatementBlock> => Statement::_if(cond, block),
};

WhileStatement: Statement = {
    "while" <cond:Expr> ":" "\n" => Statement::_while(cond, vec![]),
    "while" <cond:Expr> ":" <s:InlineStatement> => Statement::_while(cond, vec![s]),
    "while" <cond:Expr> ":" "\n" <block:StatementBlock> => Statement::_while(cond, block),
};

pub StatementList: Vec<Statement> = {
    <Statement*>,
};

StatementBlock: Vec<Statement> = {
    "indent" <StatementList> "dedent",
};

extern {
    type Location = usize;
    type Error = LexerError;

    enum Token<'input> {
        // WHITESPACE
        "\n" => Token::Newline,
        "indent" => Token::Indent,
        "dedent" => Token::Dedent,

        // VALUES
        None => Token::None,
        Bool => Token::Bool(<bool>),
        Int => Token::Int(<IntBuilder<'input>>),
        Float => Token::Float(<FloatBuilder<'input>>),
        Str => Token::Str(<StrFormat<'input>>),
        Ident => Token::Ident(<&'input str>),

        // KEYWORDS
        "if" => Token::If,
        "while" => Token::While,

        // BRACES
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "[" => Token::OpenSquare,
        "]" => Token::CloseSquare,

        // CONTROL
        "." => Token::Dot,
        "=" => Token::Assign,
        "?" => Token::Question,
        ":" => Token::Colon,
        "::" => Token::DoubleColon,

        // OPERATORS
        "+" => Token::Add,
        "-" => Token::Sub,
        "!" => Token::Not,
        "*" => Token::Mul,
        "/" => Token::Div,
        "%" => Token::Mod,
        "**" => Token::Pow,
        "==" => Token::Eq,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "!=" => Token::NEq,
        "<=" => Token::LtEq,
        ">=" => Token::GtEq,
        "&&" => Token::And,
        "||" => Token::Or,
    }
}
