use boba_script_ast::{
    Expr,
    Statement,
    Func,
    int::IBig,
};
use boba_script_lexer::{
    Token,
    LexerError,
    token::build::{
        IntBuilder,
        FloatBuilder,
        StrFormat,
    },
};

grammar<'input>(input: &'input str);

Bool: bool = {
    <bool>,
};

Int: IBig = {
    <v:int> => v.build(),
};

Float: f64 = {
    <v:float> => v.build(),
};

Str: String = {
    <v:str> => v.format(),
};

Ident: String = {
    <v:ident> => v.to_string(),
}

Atom: Expr = {
    none => Expr::none(),
    <Bool> => Expr::bool(<>),
    <Int> => Expr::int(<>),
    <Float> => Expr::float(<>),
    <Str> => Expr::str(<>),
    <Ident> => Expr::var(<>),
    "(" <Expr> ")",
};

pub Expr: Expr = {
    #[precedence(level="0")]
    <Atom>,

    #[precedence(level="1")] #[assoc(side="right")]
    <l:Expr> "**" <r:Expr> => l.pow(r),

    #[precedence(level="2")] #[assoc(side="right")]
    "+" <e: Expr> => e.pos(),
    "-" <e: Expr> => e.neg(),
    "!" <e: Expr> => e.not(),

    #[precedence(level="3")] #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => l.add(r),
    <l:Expr> "-" <r:Expr> => l.sub(r),

    #[precedence(level="4")] #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => l.mul(r),
    <l:Expr> "/" <r:Expr> => l.div(r),
    <l:Expr> "%" <r:Expr> => l._mod(r),

    #[precedence(level="5")] #[assoc(side="left")]
    <l:Expr> "&&" <r:Expr> => l.and(r),
    <l:Expr> "||" <r:Expr> => l.or(r),

    #[precedence(level="6")] #[assoc(side="left")]
    <l:Expr> "==" <r:Expr> => l.eq(r),
    <l:Expr> "<" <r:Expr> => l.lt(r),
    <l:Expr> ">" <r:Expr> => l.gt(r),
    <l:Expr> "!=" <r:Expr> => l.neq(r),
    <l:Expr> "<=" <r:Expr> => l.lteq(r),
    <l:Expr> ">=" <r:Expr> => l.gteq(r),
};

pub Statement: Statement = {
    <InlineStatement>,
    <IfStatement>,
    <WhileStatement>,
    <FunctionDef>,
};

InlineStatement: Statement = {
    <Expr> "\n" => Statement::expr(<>),
    <l:Expr> "=" <r:Expr> "\n" => Statement::assign(l, r),
};

IfStatement: Statement = {
    "if" <cond:Expr> ":" "\n" => Statement::_if(cond, vec![]),
    "if" <cond:Expr> ":" <s:InlineStatement> => Statement::_if(cond, vec![s]),
    "if" <cond:Expr> ":" "\n" <block:StatementBlock> => Statement::_if(cond, block),
};

WhileStatement: Statement = {
    "while" <cond:Expr> ":" "\n" => Statement::_while(cond, vec![]),
    "while" <cond:Expr> ":" <s:InlineStatement> => Statement::_while(cond, vec![s]),
    "while" <cond:Expr> ":" "\n" <block:StatementBlock> => Statement::_while(cond, block),
};

FunctionDef: Statement = {
    "fn" <name:Ident> "(" <params:IdentList> ")" ":" "\n" => 
        Statement::assign(Expr::var(name), Expr::_fn(Func::new(params, vec![]))),
    "fn" <name:Ident> "(" <params:IdentList> ")" ":" <s:InlineStatement> => 
        Statement::assign(Expr::var(name), Expr::_fn(Func::new(params, vec![s]))),
    "fn" <name:Ident> "(" <params:IdentList> ")" ":" "\n" <block:StatementBlock> => 
        Statement::assign(Expr::var(name), Expr::_fn(Func::new(params, block))),
};

pub StatementList: Vec<Statement> = {
    <Statement*>,
};

StatementBlock: Vec<Statement> = {
    "indent" <StatementList> "dedent",
};

IdentList: Vec<String> = {
    <mut idents:(<Ident> ",")*> <last:Ident?> => match last {
        None => idents,
        Some(last) => {
            idents.push(last);
            idents
        }
    }
};

extern {
    type Location = usize;
    type Error = LexerError;

    enum Token<'input> {
        // WHITESPACE
        "\n" => Token::Newline,
        "indent" => Token::Indent,
        "dedent" => Token::Dedent,

        // VALUES
        none => Token::None,
        bool => Token::Bool(<bool>),
        int => Token::Int(<IntBuilder<'input>>),
        float => Token::Float(<FloatBuilder<'input>>),
        str => Token::Str(<StrFormat<'input>>),
        ident => Token::Ident(<&'input str>),

        // KEYWORDS
        "if" => Token::If,
        "while" => Token::While,
        "fn" => Token::Fn,

        // BRACES
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "[" => Token::OpenSquare,
        "]" => Token::CloseSquare,

        // CONTROL
        "." => Token::Dot,
        "," => Token::Comma,
        "=" => Token::Assign,
        "?" => Token::Question,
        ":" => Token::Colon,
        "::" => Token::DoubleColon,

        // OPERATORS
        "+" => Token::Add,
        "-" => Token::Sub,
        "!" => Token::Not,
        "*" => Token::Mul,
        "/" => Token::Div,
        "%" => Token::Mod,
        "**" => Token::Pow,
        "==" => Token::Eq,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "!=" => Token::NEq,
        "<=" => Token::LtEq,
        ">=" => Token::GtEq,
        "&&" => Token::And,
        "||" => Token::Or,
    }
}
